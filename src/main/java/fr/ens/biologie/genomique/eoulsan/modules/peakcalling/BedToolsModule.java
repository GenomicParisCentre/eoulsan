package fr.ens.biologie.genomique.eoulsan.modules.peakcalling;

import static fr.ens.biologie.genomique.eoulsan.EoulsanLogger.getLogger;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Set;
import java.util.List;
import com.google.common.base.Joiner;
import java.util.Collections;

import fr.ens.biologie.genomique.eoulsan.EoulsanException;
import fr.ens.biologie.genomique.eoulsan.EoulsanRuntime;
import fr.ens.biologie.genomique.eoulsan.Globals;
import fr.ens.biologie.genomique.eoulsan.annotations.LocalOnly;
import fr.ens.biologie.genomique.eoulsan.core.InputPorts;
import fr.ens.biologie.genomique.eoulsan.core.InputPortsBuilder;
import fr.ens.biologie.genomique.eoulsan.core.OutputPorts;
import fr.ens.biologie.genomique.eoulsan.core.OutputPortsBuilder;
import fr.ens.biologie.genomique.eoulsan.core.Parameter;
import fr.ens.biologie.genomique.eoulsan.core.StepConfigurationContext;
import fr.ens.biologie.genomique.eoulsan.core.TaskContext;
import fr.ens.biologie.genomique.eoulsan.core.TaskResult;
import fr.ens.biologie.genomique.eoulsan.core.TaskStatus;
import fr.ens.biologie.genomique.eoulsan.core.Version;
import fr.ens.biologie.genomique.eoulsan.data.Data;
import fr.ens.biologie.genomique.eoulsan.data.DataFile;
import fr.ens.biologie.genomique.eoulsan.data.DataFormat;
import fr.ens.biologie.genomique.eoulsan.data.DataFormatRegistry;
import fr.ens.biologie.genomique.eoulsan.data.DataMetadata;
import fr.ens.biologie.genomique.eoulsan.modules.AbstractModule;
import fr.ens.biologie.genomique.eoulsan.util.BinariesInstaller;
import fr.ens.biologie.genomique.eoulsan.util.ProcessUtils;
import fr.ens.biologie.genomique.eoulsan.requirements.Requirement;
import fr.ens.biologie.genomique.eoulsan.requirements.DockerRequirement;
import fr.ens.biologie.genomique.eoulsan.util.process.DockerManager;
import fr.ens.biologie.genomique.eoulsan.util.process.SimpleProcess;
import fr.ens.biologie.genomique.eoulsan.design.Design;
import fr.ens.biologie.genomique.eoulsan.design.Experiment;
import fr.ens.biologie.genomique.eoulsan.design.ExperimentSample;
import fr.ens.biologie.genomique.eoulsan.design.DesignUtils;
import fr.ens.biologie.genomique.eoulsan.design.Sample;

/**
 * This class uses tools from the BEDTools suite.
 * @author Celine Hernandez - CSB lab - ENS - Paris
 */
@LocalOnly
public class BedToolsModule extends AbstractModule {

  private static final String SOFTWARE_LABEL = "bedtools";

  private static DataFormat PEAK =
      DataFormatRegistry.getInstance().getDataFormatFromName("peaks");

  private Requirement requirement;

  final String dockerImage = "genomicpariscentre/bedtools:latest";

  /**
   * Methods
   */

  @Override
  public String getName() {
    return "bedtools";
  }

  @Override
  public String getDescription() {
    return "This step runs a tool from the BEDTools suite.";
  }

  @Override
  public Version getVersion() {
    return Globals.APP_VERSION;
  }

  @Override
  public InputPorts getInputPorts() {
    final InputPortsBuilder builder = new InputPortsBuilder();
    builder.addPort("inputlist", true, PEAK);
    return builder.create();
  }

  @Override
  public OutputPorts getOutputPorts() {
    final OutputPortsBuilder builder = new OutputPortsBuilder();
    builder.addPort("outputlist", true, PEAK);
    return builder.create();
  }

  /**
   * Set the parameters of the step to configure the step.
   * @param stepParameters parameters of the step
   * @throws EoulsanException if a parameter is invalid
   */
  @Override
  public void configure(final StepConfigurationContext context,
      final Set<Parameter> stepParameters) throws EoulsanException {

    for (Parameter p : stepParameters) {

      getLogger().info(
          "BEDTools parameter: " + p.getName() + " : " + p.getStringValue());

      throw new EoulsanException(
          "Unknown parameter for " + getName() + " step: " + p.getName());
    }

    this.requirement = DockerRequirement.newDockerRequirement(dockerImage, true);

  }

  @Override
  public Set<Requirement> getRequirements() {
    return Collections.singleton(this.requirement);
  }

  /**
   * Run bedtools multiinter. Installation (if needed) was made during
   * configuration.
   */
  @Override
  public TaskResult execute(final TaskContext context,
      final TaskStatus status) {

    //getLogger().info("Running BEDTools " + this.bedtoolsPath);

    // Get input data (PEAK format, as generated by )
    final Data inData = context.getInputData(PEAK);

    final Design design = context.getWorkflow().getDesign();

    int nombre = 1;

    //Construction of a HashMap containing a SampleName as String corresponding to a specific Data.
    HashMap<String, Data> nameMap =
        new HashMap<String, Data>(inData.getListElements().size() / 2);
    for(Data anInputData : inData.getListElements()){
      String name = anInputData.getMetadata().getSampleName();
      nameMap.put(name, anInputData);
      getLogger().info(nombre + " nomSample : " + name);
      nombre = nombre + 1;
    }

    // First sort data into experiments/replicate groups before we can
    // concatenate what is inside each group
    HashMap<String, ArrayList<Data>> expMap =
        new HashMap<String, ArrayList<Data>>(
            inData.getListElements().size() / 2);
    for (Experiment e : design.getExperiments()) {

      for(ExperimentSample expSam : e.getExperimentSamples()){

        getLogger().info("Input file. ref : "
            + DesignUtils.getReference(expSam) + "| exp : "
            + e.getName() + "| rep : "
            + DesignUtils.getRepTechGroup(expSam));

        boolean isReference = DesignUtils.getReference(expSam).toLowerCase().equals("true");

        // if we have a control
        
          // Should we add its peaks also ? Not, for now.
          if (isReference) {
            getLogger().info("Reference file, not treated.");
            continue;
          }
          getLogger().info("Not a reference file. Proceeding.");

          // if we have a sample

          // Access the sample metadata and concatenate values
          // in order to create a key used to sort samples by category
          // (experiment and replicate group)
          String experimentName = e.getName();
          String sortingKey = experimentName;

          // Store current sample in expmap
          // If it's the first in its category, create a new container before
          if (expMap.get(sortingKey) == null) {
            ArrayList<Data> tmpList = new ArrayList<Data>();
            tmpList.add(nameMap.get(expSam.getSample().getName()));
            expMap.put(sortingKey, tmpList);
          } else {
            expMap.get(sortingKey).add(nameMap.get(expSam.getSample().getName()));
          }
          getLogger().info("Now "
              + expMap.get(sortingKey).size() + " samples for experiment "
              + sortingKey);
      }
    }

    final Data peakDataList = context.getOutputData(PEAK, "mergedPeaklist");

    // Loop through each sorted category
    // to apply bedtools mergeinter
    for (String experimentName : expMap.keySet()) {

      // Get all samples of current category
      ArrayList<Data> expDataList = expMap.get(experimentName);
      ArrayList<Data> expDataList2 = new ArrayList<Data>();

      for (int i=0; i < expDataList.size(); i++){
	getLogger().info("pour " + experimentName + " Data " + i + " : " + expDataList.get(i));

	if (expDataList.get(i) != null){
	  expDataList2.add(expDataList.get(i));
	}
      }

      for (int j=0; j < expDataList2.size(); j++){
	getLogger().info("expDataList2; pour " + experimentName + " Data " + j + " : " + expDataList2.get(j));
      }

      // Do not merge if we have only one file
      // Copy and change name to make it available in Eoulsan for the rest of
      // the analysis

      getLogger().info("nombre de fichiers pour " + experimentName + " : " + expDataList2.size());

      if (expDataList.size() < 2) {
        getLogger().info("Data list contains only 1 sample for experiment "
            + experimentName);

        Data anInputData = expDataList2.get(0);

        final Data outputData = peakDataList.addDataToList(anInputData
            .getMetadata().getSampleName().replaceAll("[^a-zA-Z0-9]", ""));
        outputData.getMetadata().set(anInputData.getMetadata());

        try {
          anInputData.getDataFile().symlink(outputData.getDataFile());
        } catch (IOException ioe) {
          getLogger().severe("Could not create symlink from "
              + anInputData.getDataFile() + " to " + outputData.getDataFile());
          return status.createTaskResult();
        }

        continue;
      }

      // Create command line

      // Executable
      List<String> cmd = new ArrayList<String>();

      cmd.add("bedtools");
      cmd.add("multiinter");

      // Add all files to be merged
      cmd.add("-i");
      for (Data sample : expDataList2) {
        cmd.add(String.format("%s", sample.getDataFilename()));
      }

      // Get metadata of one peak file
      DataMetadata metadata = expDataList2.get(0).getMetadata();

      getLogger().info("Test metadata " + metadata.getSampleName());

      // Define the merged file : all peaks
      final Data peakData = peakDataList
          .addDataToList(metadata.getSampleName().replaceAll("[^a-zA-Z0-9]", "")
              + "Mergedpeaks");
      peakData.getMetadata().set(metadata);

      //As bedtools writes directly its results on the standard output, this outputFile will contain the merged peaks.
      //The outputFile will contain the standard output of the process.
      File outputFile = peakData.getDataFile().toFile();

      final File stderrFile = new File("docker.err");

      String cmd2 = Joiner.on(' ').join(cmd);
      getLogger().info("Run command line : " + cmd2);

      // Run bedtools
      try {

        final SimpleProcess process =
            DockerManager.getInstance().createImageInstance(dockerImage);
        final int exitValue =
            process.execute(cmd, context.getStepOutputDirectory().toFile(),
                context.getLocalTempDirectory(), outputFile, stderrFile);

        ProcessUtils.throwExitCodeException(exitValue, Joiner.on(' ').join(cmd));
      } catch (IOException err) {
        return status.createTaskResult(err);
      }
    }
    return status.createTaskResult();

  }

}
