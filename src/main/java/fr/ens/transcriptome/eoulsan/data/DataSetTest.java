package fr.ens.transcriptome.eoulsan.data;

import static fr.ens.transcriptome.eoulsan.util.FileUtils.checkExistingDirectoryFile;

import java.io.File;
import java.io.FileFilter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.logging.Logger;

import com.google.common.base.Splitter;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.sun.org.apache.xml.internal.serializer.ToUnknownStream;

import fr.ens.transcriptome.eoulsan.EoulsanException;
import fr.ens.transcriptome.eoulsan.Globals;
import fr.ens.transcriptome.eoulsan.util.FileUtils;
import fr.ens.transcriptome.eoulsan.util.ProcessUtils;
import fr.ens.transcriptome.eoulsan.util.StringUtils;

public class DataSetTest {

  /** Logger */
  private static final Logger LOGGER = Logger.getLogger(Globals.APP_NAME);

  private final Splitter splitter = Splitter.on(' ').trimResults()
      .omitEmptyStrings();

  private final Map<String, File> parametersFiles;
  private final boolean expected;

  private final Properties props;

  private File inputDataProject;
  private final File inputDataDirectory;
  private File outputDataProject;
  private final File outputDataDirectory;

  private File designFile;
  private Collection<File> fastqFiles;
  private boolean toGenerateAnalysisResult = true;

  // Data for execute Eoulsan
  private File eoulsanPath;
  private List<String> eoulsanArguments;

  // Optional scripts
  private String preScriptPath;
  private String postScriptPath;

  public Map<String, DataSetAnalysis> execute() throws EoulsanException,
      IOException {

    Map<String, DataSetAnalysis> tests =
        Maps.newHashMapWithExpectedSize(parametersFiles.size());

    // Check if Eoulsan must be launch on input data
    for (String testName : parametersFiles.keySet()) {

      final File outputTest = new File(outputDataProject, "test_" + testName);

      LOGGER.info(testName
          + "  ==>  launch eoulsan on each parameter file in "
          + outputTest.getAbsolutePath());

      final DataSetAnalysis dsa =
          new DataSetAnalysis(outputTest, outputTest.exists(),
              parametersFiles.get(testName), this);

      // Create result directory
      dsa.buildDirectoryAnalysis();

      // Launch Eoulsan on input data if an new parameter file added
      if (toGenerateAnalysisResult || !outputTest.exists()) {
        // Launch Eoulsan on data and create results directory
        launchAnalysis(dsa, outputTest);
      }

      // Collect all files generated by analysis Eoulsan
      dsa.parseDirectory(outputTest);

      // Add in test map
      tests.put(testName, dsa);
    }

    return tests;
  }

  //
  // Private methods
  //

  private void launchAnalysis(final DataSetAnalysis dsa, final File outputTest)
      throws IOException {

    int exitValue;

    // If exists, launch preScript analysis
    if (this.preScriptPath != null) {
      exitValue =
          ProcessUtils.sh(Lists.newArrayList(this.preScriptPath), new File(
              this.preScriptPath).getParentFile());

      if (exitValue != 0) {
        throw new IOException("Error during execution pre-script analysis "
            + this.preScriptPath + " exitValue: " + exitValue);
      }
    }

    // TODO
    // Launch eoulsan
    exitValue = ProcessUtils.sh(buildCommandLine(dsa), outputTest);

    // Check exitvalue
    if (exitValue != 0) {
      throw new IOException("Bad error result for dataset "
          + outputTest.getAbsolutePath() + " execution: " + exitValue);
    }

    // If exists, launch postScript analysis
    if (this.postScriptPath != null) {
      exitValue =
          ProcessUtils.sh(Lists.newArrayList(this.postScriptPath), new File(
              this.postScriptPath).getParentFile());

      if (exitValue != 0) {
        throw new IOException("Error during execution post-script analysis "
            + this.postScriptPath + " exitValue: " + exitValue);
      }
    }
  }

  private List<String> buildCommandLine(final DataSetAnalysis dsa) {

    List<String> cmd = Lists.newLinkedList();

    // cmd.add("screen");
    cmd.add(eoulsanPath + "/eoulsan.sh");
    // cmd.add("-help");

    // Add arguments from configuration file
    cmd.addAll(eoulsanArguments);

    cmd.add(dsa.getParamFile().toFile().getAbsolutePath());
    cmd.add(dsa.getDesignFile().toFile().getAbsolutePath());

    LOGGER.info(StringUtils.join(cmd.toArray(), " "));
    // TODO
    System.out.println(StringUtils.join(cmd.toArray(), " "));

    return cmd;
  }

  private void init() throws IOException {

    final String projectName = inputDataDirectory.getName();
    final String typeDataSetUsed = this.props.getProperty("type_data_used");
    this.inputDataProject = new File(inputDataDirectory, typeDataSetUsed);

    checkExistingDirectoryFile(
        this.inputDataProject,
        "Project directory doesn't exist in directory "
            + inputDataProject.getAbsolutePath());

    // At the root of type input data directory
    this.designFile = filterFile(inputDataProject, ".txt")[0];

    // Collect all fastq files for project
    this.fastqFiles =
        Arrays.asList(filterFile(inputDataProject, ".fastq.bz2", "fq.bz2",
            "fastq", "fq"));

    // Retrieve argument for command line eoulsan
    this.eoulsanArguments =
        Lists.newLinkedList(splitter.split(props
            .getProperty("command_line_argument_eoulsan")));

    if (expected) {
      this.eoulsanPath = new File(props.getProperty("eoulsan_reference_path"));

      checkExistingDirectoryFile(
          this.eoulsanPath,
          "Eoulsan executable doesn't exist for reference in "
              + eoulsanPath.getAbsolutePath());

      // this.eoulsanVersionGit =
      // props.getProperty("eoulsan_reference_version_git");

      this.outputDataProject =
          new File(this.outputDataDirectory, projectName
              + "_" + typeDataSetUsed);

    } else {
      // DataSetTest for the version Eoulsan to test

      // Case test directory to generate
      this.eoulsanPath =
          new File(props.getProperty("eoulsan_version_to_test_path"));
      checkExistingDirectoryFile(
          this.eoulsanPath,
          "Eoulsan executable doesn't exist for test in "
              + eoulsanPath.getAbsolutePath());

      // this.eoulsanVersionGit = props.getProperty("eoulsan_test_version_git");

      this.outputDataProject =
          new File(this.outputDataDirectory, projectName
              + "_" + typeDataSetUsed);

    }

    if (toGenerateAnalysisResult) {

      if (this.outputDataProject.exists())
        throw new IOException("Output data directory to test already exists "
            + this.outputDataProject);

      if (!this.outputDataProject.mkdirs())
        throw new IOException("Cannot create output directory "
            + this.outputDataProject.getAbsolutePath());

    }

    // Retrieve script pre- and post- analysis if exists
    String path = props.getProperty("local_shell_script_pretreatment");
    if (path != null)
      if (new File(path).exists()) {
        this.preScriptPath =
            props.getProperty("local_shell_script_pretreatment");

        LOGGER
            .info("Configuration specified a pre-script to execute before analysis "
                + this.preScriptPath);
      } else {
        throw new IOException("Pre-script analysis doesn't exist: " + path);
      }

    path = props.getProperty("local_shell_script_posttreatment");
    if (path != null)
      if (new File(path).exists()) {
        this.postScriptPath =
            props.getProperty("local_shell_script_posttreatment");

        LOGGER
            .info("configuration specified a post-script to execute after analysis "
                + this.postScriptPath);

      } else {
        throw new IOException("Post-script analysis doesn't exist: " + path);
      }

  }

  private File[] filterFile(final File dir, final String... suffixes) {

    return dir.listFiles(new FileFilter() {

      @Override
      public boolean accept(File pathname) {
        for (String suffix : suffixes)
          return pathname.getName().contains(suffix);
        return false;
      }
    });
  }

  //
  // Getter
  //
  public File getDesignFile() {
    return this.designFile;
  }

  public Collection<File> getFastqFiles() {
    return this.fastqFiles;
  }

  //
  // Constructor
  //
  public DataSetTest(final Properties props,
      final Map<String, File> parametersFiles, final File inputData,
      final File outputData, final boolean newVersionEoulsan)
      throws IOException {

    this.props = props;
    this.parametersFiles = parametersFiles;
    this.inputDataDirectory = inputData;
    this.outputDataDirectory = outputData;
    this.expected = true;
    this.toGenerateAnalysisResult = newVersionEoulsan && this.expected;

    init();

  }

  public DataSetTest(final Properties props,
      final Map<String, File> parametersFiles, final File inputData,
      final File outputData) throws IOException {

    this.props = props;
    this.parametersFiles = parametersFiles;
    this.inputDataDirectory = inputData;
    this.outputDataDirectory = outputData;
    this.expected = false;
    this.toGenerateAnalysisResult = true;

    init();

  }

}
