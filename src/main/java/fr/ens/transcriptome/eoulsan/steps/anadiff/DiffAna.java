/*
 *                  Eoulsan development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public License version 2.1 or
 * later and CeCILL-C. This should be distributed with the code.
 * If you do not have a copy, see:
 *
 *      http://www.gnu.org/licenses/lgpl-2.1.txt
 *      http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.txt
 *
 * Copyright for this code is held jointly by the Genomic platform
 * of the Institut de Biologie de l'École Normale Supérieure and
 * the individual authors. These should be listed in @author doc
 * comments.
 *
 * For more information on the Eoulsan project and its aims,
 * or to join the Eoulsan Google group, visit the home page
 * at:
 *
 *      http://www.transcriptome.ens.fr/eoulsan
 *
 */

package fr.ens.transcriptome.eoulsan.steps.anadiff;

import static com.google.common.base.Preconditions.checkNotNull;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.logging.Logger;

import fr.ens.transcriptome.eoulsan.EoulsanException;
import fr.ens.transcriptome.eoulsan.Globals;
import fr.ens.transcriptome.eoulsan.design.Design;
import fr.ens.transcriptome.eoulsan.design.Sample;
import fr.ens.transcriptome.eoulsan.util.FileUtils;
import fr.ens.transcriptome.eoulsan.util.ProcessUtils;
import fr.ens.transcriptome.eoulsan.util.StringUtils;

/**
 * This class create and launch a R script to compute differential analysis.
 * @author Laurent Jourdren
 */
public class DiffAna {

  /** Logger. */
  private static final Logger LOGGER = Logger.getLogger(Globals.APP_NAME);

  private static final String ANADIFF_SCRIPT = "/anadiff.R";

  private Design design;
  private File tempDir;
  private File expressionFilesDirectory;
  private String expressionFilesPrefix;
  private String expressionFilesSuffix;

  /**
   * Execute the analysis.
   * @throws EoulsanException if an error occurs while creating or executing the
   *           R script
   */
  public void run() throws EoulsanException {

    final Map<String, Integer> conditionsMap = new HashMap<String, Integer>();

    final List<Integer> rSampleIds = new ArrayList<Integer>();
    final List<String> rSampleNames = new ArrayList<String>();
    final List<String> rCondNames = new ArrayList<String>();
    final List<Integer> rCondIndexes = new ArrayList<Integer>();
    final List<String> rCondRep = new ArrayList<String>();

    // Get samples ids, conditions names/indexes and replicat types
    for (Sample s : this.design.getSamples()) {

      if (!s.getMetadata().isConditionField())
        throw new EoulsanException("No condition field found in design file.");

      if (!s.getMetadata().isReplicatTypeField())
        throw new EoulsanException(
            "No ReplicatType field found in design file.");

      final String condition = s.getMetadata().getCondition().trim();
      final String replicatType =
          s.getMetadata().getReplicatType().trim().toLowerCase();

      if ("".equals(condition))
        throw new EoulsanException("No value for condtion in sample: "
            + s.getName() + " (" + s.getId() + ")");
      if (!("t".equals(replicatType) || "b".equals(replicatType)))
        throw new EoulsanException("Invalid replicat type ("
            + replicatType + ") for condtion in sample: " + s.getName() + " ("
            + s.getId() + ")");

      if (!conditionsMap.containsKey(condition)) {
        conditionsMap.put(condition, conditionsMap.size() + 1);
        rCondNames.add(condition);
      }

      rSampleIds.add(s.getId());
      rSampleNames.add(s.getName());
      rCondIndexes.add(conditionsMap.get(condition));
      rCondRep.add(replicatType);
    }

    final StringBuilder sb = new StringBuilder();

    sb.append("### Auto generated by ");
    sb.append(Globals.APP_NAME);
    sb.append(" ");
    sb.append(Globals.APP_VERSION_STRING);
    sb.append(" on ");
    sb.append(new Date(System.currentTimeMillis()));
    sb.append(" ###\n\n");

    // Add function part of the script
    sb.append(readStaticScript());

    if (isBiologicalReplicates(rCondIndexes, rCondRep))
      writeWithBiologicalReplicate(sb, rSampleIds, rSampleNames, rCondIndexes,
          rCondNames, rCondRep);
    else
      writeWithoutBiologicalReplicate(sb, rSampleIds, rSampleNames,
          rCondIndexes, rCondNames);

    final File rScript;

    try {
      rScript = FileUtils.createTempFile(this.tempDir, "anadiff", ".R");

      LOGGER.fine("rScript: " + rScript.getAbsolutePath());

      Writer writer = FileUtils.createFastBufferedWriter(rScript);
      writer.write(sb.toString());
      writer.close();

      // Set script executable
      rScript.setExecutable(true);

    } catch (IOException e) {

      throw new EoulsanException("Error while creating R script in anadiff: "
          + e.getMessage());
    }

    try {

      final ProcessBuilder pb =
          new ProcessBuilder("/usr/bin/R", "-f",
              StringUtils.bashEscaping(rScript.getAbsolutePath()));

      // Set the temporary directory for R
      pb.environment().put("TMPDIR", this.tempDir.getAbsolutePath());

      ProcessUtils.logEndTime(pb.start(), pb.toString(),
          System.currentTimeMillis());

      if (!rScript.delete())
        LOGGER.warning("Unable to remove R script: "
            + rScript.getAbsolutePath());

    } catch (IOException e) {

      throw new EoulsanException("Error while executing R script in anadiff: "
          + e.getMessage());
    }

  }

  /**
   * Read the static part of the the generated script.
   * @return a String with the static part of the script
   */
  private String readStaticScript() {

    final StringBuilder sb = new StringBuilder();

    final InputStream is = DiffAna.class.getResourceAsStream(ANADIFF_SCRIPT);

    try {
      final BufferedReader br = FileUtils.createBufferedReader(is);

      String line;

      while ((line = br.readLine()) != null) {

        sb.append(line);
        sb.append('\n');
      }
    } catch (IOException e) {
    }

    return sb.toString();
  }

  /**
   * Test if there is biological replicates
   * @param rCondIndexes R conditions indexes
   * @param rCondRep R condition replicat
   * @return true if there is some biological replicates
   */
  private boolean isBiologicalReplicates(List<Integer> rCondIndexes,
      final List<String> rCondRep) {

    final Map<Integer, Integer> map = new HashMap<Integer, Integer>();

    for (int i = 0; i < rCondIndexes.size(); i++) {

      final int index = rCondIndexes.get(i);
      final boolean biologicalReplicate =
          "b".equals(rCondRep.get(i).trim().toLowerCase());

      if (!biologicalReplicate)
        continue;

      if (map.containsKey(index))
        map.put(index, map.get(index) + 1);
      else
        map.put(index, 1);

    }

    for (int count : map.values())
      if (count > 1)
        return true;

    return false;
  }

  /**
   * Write the load data part of the R script
   * @param sb StringBuilder to use to write data
   * @param rSampleIds R samples ids
   * @param rSampleNames R samples names
   * @param rCondIndexes R conditions indexes
   * @param rCondNames R conditions names
   */
  private void writeLoadData(final StringBuilder sb,
      final List<Integer> rSampleIds, final List<String> rSampleNames,
      final List<Integer> rCondIndexes, final List<String> rCondNames) {

    // Read files
    boolean first = true;
    for (int i = 0; i < rSampleIds.size(); i++) {

      sb.append("expr");
      sb.append(i + 1);
      sb.append(" = read.table(\"");
      sb.append(StringUtils.bashEscaping(this.expressionFilesDirectory
          .getAbsolutePath()));
      sb.append('/');
      sb.append(this.expressionFilesPrefix);
      sb.append(rSampleIds.get(i));
      sb.append(this.expressionFilesSuffix);
      sb.append("\",header=T,stringsAsFactors=F)[,c(1,11)]\n");

      if (first)
        first = false;
      else {

        sb.append("expr1 = merge(expr1,expr");
        sb.append(i + 1);
        sb.append(",by.x=\"Id\",by.y=\"Id\")\n");

      }

      sb.append("colnames(expr1)[dim(expr1)[2]]=\"");
      sb.append(rSampleNames.get(i));
      sb.append("\"\n\n");

    }

    sb.append("count =  expr1[,-1]\n" + "rownames(count) = expr1[,1]\n\n");

    // Add conditions names to R script
    sb.append("# vector of condition Names\n");
    sb.append("condNames = c(");
    first = true;
    for (String c : rCondNames) {

      if (first)
        first = false;
      else
        sb.append(',');
      sb.append('"');
      sb.append(c);
      sb.append('"');
    }
    sb.append(")\n");

    // Add conditions indexes to R script
    sb.append("#vector of condition code for each colomne of the count tab. condition 1 corresponding to the first name in the condNames vector ...\n");
    sb.append("cond = c(");
    first = true;
    for (int i : rCondIndexes) {

      if (first)
        first = false;
      else
        sb.append(',');

      sb.append(i);
    }
    sb.append(")\n");

  }

  /**
   * Write code without biological replicates.
   * @param sb StringBuilder to use
   * @param rSampleIds R samples ids
   * @param rSampleNames R samples names
   * @param rCondIndexes R conditions indexes
   * @param rCondNames R conditions names
   */
  private void writeWithoutBiologicalReplicate(final StringBuilder sb,
      final List<Integer> rSampleIds, final List<String> rSampleNames,
      final List<Integer> rCondIndexes, final List<String> rCondNames) {

    writeLoadData(sb, rSampleIds, rSampleNames, rCondIndexes, rCondNames);

    sb.append("# Sum of technical replicates (if there is technical replicat) and normalisation\n"
        + "# for all conditions sums of technical replicates expression\n"
        + "tab=c()\n"
        + "for (i in 1:length(unique(cond)))\n"
        + "{\n"
        + "  tab = cbind(tab,rowSums(count[which(cond == i)]))\n"
        + "}\n\n"
        + "colnames(tab) = condNames\n"
        + "rownames(tab)=rownames(count)\n\n"
        + "# deleting genes that are not expressed in any condition\n"
        + "tab = tab[rowSums(tab)>0,]\n\n");

    for (int i = 0; i < rCondNames.size(); i++)
      for (int j = i + 1; j < rCondNames.size(); j++) {

        sb.append("# path to the output file\n" + "out = \"diffana-");
        sb.append(rCondNames.get(i));
        sb.append('-');
        sb.append(rCondNames.get(j));
        sb.append(".txt\"\n"
            + "# statistical analysis of differentially expressed genes of condition 1 vs condition 2 (give the names)\n"
            + "ana_diff_without_bio_rep(tab, condNames[");
        sb.append(i + 1);
        sb.append("],condNames[");
        sb.append(j + 1);
        sb.append("],out) # condition 1 vs condition 2\n\n");
      }

  }

  /**
   * Write code without biological replicates.
   * @param sb StringBuilder to use
   * @param rSampleIds R samples ids
   * @param rSampleNames R samples names
   * @param rCondIndexes R conditions indexes
   * @param rCondNames R conditions names
   * @param RCondRep R conditions replicates
   */
  private void writeWithBiologicalReplicate(final StringBuilder sb,
      final List<Integer> rSampleIds, final List<String> rSampleNames,
      final List<Integer> rCondIndexes, final List<String> rCondNames,
      final List<String> rCondRep) {

    writeLoadData(sb, rSampleIds, rSampleNames, rCondIndexes, rCondNames);

    // Add replicates to R script
    sb.append("# vector of condition Names\n");
    sb.append("rep = c(");
    boolean first = true;
    for (String r : rCondRep) {

      if (first)
        first = false;
      else
        sb.append(',');
      sb.append('\'');
      sb.append(r.toUpperCase());
      sb.append('\'');
    }
    sb.append(")\n");

    sb.append("library(DESeq)\n");
    sb.append("\ncds = ana_diff_with_bio_rep(count,cond,rep)\n");

    for (int i = 0; i < rCondNames.size(); i++)
      for (int j = i + 1; j < rCondNames.size(); j++) {

        sb.append("# path of the output file\n");
        sb.append("out = \"diffana-");
        sb.append(rCondNames.get(i));
        sb.append('-');
        sb.append(rCondNames.get(j));
        sb.append(".txt\"\n");

        sb.append("resDESeqAll=nbinomTest(cds,"); // 2,1)\n"
        sb.append(j + 1);
        sb.append(',');
        sb.append(i + 1);
        sb.append(")\n");

        sb.append("res = resDESeqAll[order(resDESeqAll$padj),]\n");
        sb.append("write.table(res,out,quote=F, row.names=F, sep='\t')\n\n");

      }

  }

  //
  // Constructor
  //

  /**
   * Public constructor.
   * @param design Design to set
   */
  public DiffAna(final Design design, final File expressionFilesDirectory,
      final String expressionFilesPrefix, final String expressionFilesSuffix,
      final File tempDir) {

    checkNotNull(design, "design is null.");
    checkNotNull(expressionFilesDirectory,
        "The path of the expression files is null.");
    checkNotNull(expressionFilesPrefix,
        "The prefix for expression files is null");
    checkNotNull(expressionFilesSuffix,
        "The suffix for expression files is null");

    this.design = design;
    this.tempDir = tempDir;
    this.expressionFilesPrefix = expressionFilesPrefix;
    this.expressionFilesSuffix = expressionFilesSuffix;

    if (!(expressionFilesDirectory.isDirectory() && expressionFilesDirectory
        .exists()))
      throw new NullPointerException(
          "The path of the expression files doesn't exist or is not a directory.");

    this.expressionFilesDirectory = expressionFilesDirectory;
  }

}
