/*
 *                      Nividic development code
 *
 * This code may be freely distributed and modified under the
 * terms of the GNU Lesser General Public Licence.  This should
 * be distributed with the code.  If you do not have a copy,
 * see:
 *
 *      http://www.gnu.org/copyleft/lesser.html
 *
 * Copyright for this code is held jointly by the microarray platform
 * of the École Normale Supérieure and the individual authors.
 * These should be listed in @author doc comments.
 *
 * For more information on the Nividic project and its aims,
 * or to join the Nividic mailing list, visit the home page
 * at:
 *
 *      http://www.transcriptome.ens.fr/nividic
 *
 */

package fr.ens.transcriptome.eoulsan.steps.anadiff;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import fr.ens.transcriptome.eoulsan.EoulsanException;
import fr.ens.transcriptome.eoulsan.Globals;
import fr.ens.transcriptome.eoulsan.design.Design;
import fr.ens.transcriptome.eoulsan.design.Sample;
import fr.ens.transcriptome.eoulsan.util.FileUtils;
import fr.ens.transcriptome.eoulsan.util.ProcessUtils;
import fr.ens.transcriptome.eoulsan.util.StringUtils;

/**
 * This class create and launch a R script to compute differential analysis.
 * @author Laurent Jourdren
 */
public class AnaDiff {

  private static final String ANADIFF_SCRIPT = "/anadiff.R";

  private Design design;
  private File expressionFilesDirectory;

  private String readStaticScript() {

    final StringBuilder sb = new StringBuilder();

    final InputStream is = AnaDiff.class.getResourceAsStream(ANADIFF_SCRIPT);

    try {
      final BufferedReader br = FileUtils.createBufferedReader(is);

      String line;

      while ((line = br.readLine()) != null) {

        sb.append(line);
        sb.append('\n');
      }
    } catch (IOException e) {
    }

    return sb.toString();
  }

  public void run() throws EoulsanException {

    final Map<String, Integer> conditionsMap = new HashMap<String, Integer>();

    final List<Integer> rSampleIds = new ArrayList<Integer>();
    final List<String> rSampleNames = new ArrayList<String>();
    final List<String> rCondNames = new ArrayList<String>();
    final List<Integer> rCondIndexes = new ArrayList<Integer>();
    final List<String> rCondRep = new ArrayList<String>();

    // Get samples ids, conditions names/indexes and replicat types
    for (Sample s : this.design.getSamples()) {

      if (!s.getMetadata().isCondition())
        throw new EoulsanException("No condition field found in design file.");

      if (!s.getMetadata().isReplicatType())
        throw new EoulsanException(
            "No ReplicatType field found in design file.");

      final String condition = s.getMetadata().getCondition().trim();
      final String replicatType =
          s.getMetadata().getReplicatType().trim().toLowerCase();

      if ("".equals(condition))
        throw new EoulsanException("No value for condtion in sample: "
            + s.getName() + " (" + s.getId() + ")");
      if (!("t".equals(replicatType) || "b".equals(replicatType)))
        throw new EoulsanException("Invalid replicat type ("
            + replicatType + ") for condtion in sample: " + s.getName() + " ("
            + s.getId() + ")");

      if (!conditionsMap.containsKey(condition)) {
        conditionsMap.put(condition, conditionsMap.size() + 1);
        rCondNames.add(condition);
      }

      rSampleIds.add(s.getId());
      rSampleNames.add(s.getName());
      rCondIndexes.add(conditionsMap.get(condition));
      rCondRep.add(replicatType);
    }

    final StringBuilder sb = new StringBuilder();

    sb.append("### Auto generated by ");
    sb.append(Globals.APP_NAME);
    sb.append(" ");
    sb.append(Globals.APP_VERSION_STRING);
    sb.append(" on ");
    sb.append(new Date(System.currentTimeMillis()));
    sb.append(" ###\n\n");

    // Add function part of the script
    sb.append(readStaticScript());

    if (isBiologicalReplicates(rCondIndexes, rCondRep))
      writeWithBiologicalReplicate(sb, rSampleIds, rSampleNames, rCondIndexes,
          rCondNames, rCondRep);
    else
      writeWithoutBiologicalReplicate(sb, rSampleIds, rSampleNames,
          rCondIndexes, rCondNames);

    try {
      final File rScript = File.createTempFile("anadiff", ".R");

      System.out.println("rScript: " + rScript.getAbsolutePath());

      Writer writer = FileUtils.createBufferedWriter(rScript);
      writer.write(sb.toString());
      writer.close();

      ProcessUtils.exec("/usr/bin/R -f "
          + StringUtils.bashEscaping(rScript.getAbsolutePath()), false);

      // rScript.delete();

    } catch (IOException e) {
      System.err.println(e.getMessage());
      // TODO Auto-generated catch block
      e.printStackTrace();
    }

  }

  private boolean isBiologicalReplicates(List<Integer> rCondIndexes,
      final List<String> rCondRep) {

    final Map<Integer, Integer> map = new HashMap<Integer, Integer>();

    for (int i = 0; i < rCondIndexes.size(); i++) {

      final int index = rCondIndexes.get(i);
      final boolean biologicalReplicate =
          "b".equals(rCondRep.get(i).trim().toLowerCase());

      if (!biologicalReplicate)
        continue;

      if (map.containsKey(index))
        map.put(index, map.get(index) + 1);
      else
        map.put(index, 1);

    }

    for (int count : map.values())
      if (count > 1)
        return true;

    return false;
  }

  private void writeLoadData(final StringBuilder sb,
      final List<Integer> rSampleIds, final List<String> rSampleNames,
      final List<Integer> rCondIndexes, final List<String> rCondNames) {

    // Read files
    boolean first = true;
    for (int i = 0; i < rSampleIds.size(); i++) {

      sb.append("expr");
      sb.append(i + 1);
      sb.append(" = read.table(\"");
      sb.append(StringUtils.bashEscaping(this.expressionFilesDirectory
          .getAbsolutePath()));
      sb.append("/sample_expression_");
      sb.append(rSampleIds.get(i));
      sb.append(".txt\",header=T,stringsAsFactors=F)[,c(1,11)]\n");

      if (first)
        first = false;
      else {

        sb.append("expr1 = merge(expr1,expr");
        sb.append(i + 1);
        sb.append(",by.x=\"ID\",by.y=\"ID\")\n");

      }

      sb.append("colnames(expr1)[dim(expr1)[2]]=\"");
      sb.append(rSampleNames.get(i));
      sb.append("\"\n\n");

    }

    sb.append("count =  expr1[,-1]\n" + "rownames(count) = expr1[,1]\n\n");

    // Add conditions names to R script
    sb.append("# vector of condition Names\n");
    sb.append("condNames = c(");
    first = true;
    for (String c : rCondNames) {

      if (first)
        first = false;
      else
        sb.append(',');
      sb.append('"');
      sb.append(c);
      sb.append('"');
    }
    sb.append(")\n");

    // Add conditions indexes to R script
    sb
        .append("#vector of condition code for each colomne of the count tab. condition 1 corresponding to the first name in the condNames vector ...\n");
    sb.append("cond = c(");
    first = true;
    for (int i : rCondIndexes) {

      if (first)
        first = false;
      else
        sb.append(',');

      sb.append(i);
    }
    sb.append(")\n");

  }

  private void writeWithoutBiologicalReplicate(final StringBuilder sb,
      final List<Integer> rSampleIds, final List<String> rSampleNames,
      final List<Integer> rCondIndexes, final List<String> rCondNames) {

    writeLoadData(sb, rSampleIds, rSampleNames, rCondIndexes, rCondNames);

    sb
        .append("# Sum of technical replicates (if there is technical replicat) and normalisation\n"
            + "# for all conditions sums of technical replicates expression\n"
            + "tab=c()\n"
            + "for (i in 1:length(unique(cond)))\n"
            + "{\n"
            + "  tab = cbind(tab,rowSums(count[which(cond == i)]))\n"
            + "}\n\n"
            + "colnames(tab) = condNames\n"
            + "rownames(tab)=rownames(count)\n\n"
            + "# deleting genes that are not expressed in any condition\n"
            + "tab = tab[rowSums(tab)>0,]\n\n");

    for (int i = 0; i < rCondNames.size(); i++)
      for (int j = i + 1; j < rCondNames.size(); j++) {

        sb.append("# path to the output file\n" + "out = \"out-");
        sb.append(rCondNames.get(i));
        sb.append('-');
        sb.append(rCondNames.get(j));
        sb
            .append(".txt\"\n"
                + "# statistical analysis of differentially expressed genes of condition 1 vs condition 2 (give the names)\n"
                + "ana_diff_without_bio_rep(tab, condNames[");
        sb.append(i + 1);
        sb.append("],condNames[");
        sb.append(j + 1);
        sb.append("],out) # condition 1 vs condition 2\n\n");

      }

  }

  private void writeWithBiologicalReplicate(final StringBuilder sb,
      final List<Integer> rSampleIds, final List<String> rSampleNames,
      final List<Integer> rCondIndexes, final List<String> rCondNames,
      final List<String> rCondRep) {

    writeLoadData(sb, rSampleIds, rSampleNames, rCondIndexes, rCondNames);

    // Add replicates to R script
    sb.append("# vector of condition Names\n");
    sb.append("rep = c(");
    boolean first = true;
    for (String r : rCondRep) {

      if (first)
        first = false;
      else
        sb.append(',');
      sb.append('\'');
      sb.append(r.toUpperCase());
      sb.append('\'');
    }
    sb.append(")\n");

    sb.append("library(DESeq)\n");
    sb.append("\ncds = ana_diff_with_bio_rep(count,cond,rep)\n");

    for (int i = 0; i < rCondNames.size(); i++)
      for (int j = i + 1; j < rCondNames.size(); j++) {

        sb.append("# path of the output file\n");
        sb.append("out = \"out-");
        sb.append(rCondNames.get(i));
        sb.append('-');
        sb.append(rCondNames.get(j));
        sb.append(".txt\"\n");

        sb.append("resDESeqAll=nbinomTest(cds,"); // 2,1)\n"
        sb.append(j + 1);
        sb.append(',');
        sb.append(i + 1);
        sb.append(")\n");

        sb.append("res = resDESeqAll[order(resDESeqAll$padj),]\n");
        sb.append("write.table(res,out,quote=F, row.names=F, sep='\t')\n\n");

      }

  }

  //
  // Constructor
  //

  /**
   * Public constructor.
   * @param design Design to set
   */
  public AnaDiff(final Design design, final File expressionFilesDirectory) {

    if (design == null)
      throw new NullPointerException("design is null.");

    this.design = design;

    if (expressionFilesDirectory == null)
      throw new NullPointerException(
          "The path of the expression files is null.");

    if (!(expressionFilesDirectory.isDirectory() && expressionFilesDirectory
        .exists()))
      throw new NullPointerException(
          "The path of the expression files doesn't exist or is not a directory.");

    this.expressionFilesDirectory = expressionFilesDirectory;
  }

}
